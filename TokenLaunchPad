// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

contract TokenLaunchPad {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    address public admin;
    IERC20 public token;

    struct Sale {
        uint256 id;
        address tokenAddress;
        uint256 tokenAmount;
        uint256 tokenPrice;   // Price per token in wei
        uint256 startTime;
        uint256 endTime;
        uint256 tokensSold;
        bool active;
    }

    mapping(uint256 => Sale) public sales;
    uint256 public nextSaleId = 1;

    event SaleCreated(uint256 indexed id, address indexed tokenAddress, uint256 tokenAmount, uint256 tokenPrice, uint256 startTime, uint256 endTime);
    event TokensPurchased(address indexed buyer, uint256 indexed saleId, uint256 amount);

    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin can perform this action");
        _;
    }

    constructor(address _token) {
        admin = msg.sender;
        token = IERC20(_token);
    }

    function createSale(
        address tokenAddress,
        uint256 tokenAmount,
        uint256 tokenPrice,
        uint256 startTime,
        uint256 endTime
    ) external onlyAdmin {
        require(tokenAddress != address(0), "Invalid token address");
        require(tokenAmount > 0, "Token amount must be greater than zero");
        require(tokenPrice > 0, "Token price must be greater than zero");
        require(endTime > startTime, "End time must be after start time");

        sales[nextSaleId] = Sale(
            nextSaleId,
            tokenAddress,
            tokenAmount,
            tokenPrice,
            startTime,
            endTime,
            0,
            true
        );

        emit SaleCreated(nextSaleId, tokenAddress, tokenAmount, tokenPrice, startTime, endTime);

        nextSaleId++;
    }

    function purchaseTokens(uint256 saleId, uint256 tokenAmount) external payable {
        Sale storage sale = sales[saleId];
        require(sale.active, "Sale is not active");
        require(block.timestamp >= sale.startTime && block.timestamp <= sale.endTime, "Sale is not active");
        require(tokenAmount > 0 && tokenAmount <= sale.tokenAmount.sub(sale.tokensSold), "Invalid token amount");

        uint256 cost = tokenAmount.mul(sale.tokenPrice);
        require(msg.value >= cost, "Insufficient funds");

        sale.tokensSold = sale.tokensSold.add(tokenAmount);
        token.safeTransfer(msg.sender, tokenAmount);

        emit TokensPurchased(msg.sender, saleId, tokenAmount);
    }

    function withdrawFunds() external onlyAdmin {
        payable(admin).transfer(address(this).balance);
    }

    function withdrawUnsoldTokens(uint256 saleId) external onlyAdmin {
        Sale storage sale = sales[saleId];
        require(!sale.active || block.timestamp > sale.endTime, "Sale is still active");

        uint256 unsoldTokens = sale.tokenAmount.sub(sale.tokensSold);
        if (unsoldTokens > 0) {
            token.safeTransfer(admin, unsoldTokens);
        }
    }
}
